# -*- coding: utf-8 -*-
"""TG-Copy of python_week1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZPetHYqxbbh1i3BU1visU2hTZe4bcM1_

# Python Session 1

## We will practice cleaning some Food choice task data

We are going to generate data from 20 individuals to practice our skills. In the task, participants rate 50 foods for healthiness, tastiness and choice. We are simulating this data below.
"""

import pandas as pd
import numpy as np
import random
#python packages

# Define blocks and trial structure
blocks = ['health', 'taste', 'choice']
trials_per_block = 75
participants = range(1, 21)

# Generate 50 unique foods
base_foods = [
    'apple', 'banana', 'burger', 'carrot', 'donut', 'eggs', 'fries', 'grapes', 'ice cream', 'kale',
    'pizza', 'yogurt', 'spinach', 'steak', 'candy', 'popcorn', 'mango', 'nuts', 'cheese', 'chicken',
    'broccoli', 'chocolate', 'granola', 'lettuce', 'pasta', 'salmon', 'tofu', 'soda', 'rice', 'beans',
    'cucumber', 'peach', 'bacon', 'cereal', 'toast', 'avocado', 'beef', 'peanut butter', 'cake', 'milk',
    'watermelon', 'pear', 'turkey', 'onion rings', 'oatmeal', 'cranberries', 'syrup', 'waffles', 'cookie', 'shrimp'
]
assert len(base_foods) == 50

# Assign fat and sugar levels randomly
food_properties = {}
for food in base_foods:
    fat = random.choices(['high', 'low'], weights=[0.4, 0.6])[0]
    sugar = random.choices(['high', 'low'], weights=[0.5, 0.5])[0]
    food_properties[food] = {'fat': fat, 'sugar': sugar}

# Generate trials
all_trials = []

for participant in participants:
    for block in blocks:
        for trial_num in range(1, trials_per_block + 1):
            food = random.choice(base_foods)
            rt_missing = random.random() < 0.02  # 2% chance of missing RT
            reaction_time = None if rt_missing else round(random.uniform(0.5, 4.0), 2)
            # run into 2 decimal points
            rating = None if reaction_time is None else random.randint(1, 10)

            fat = food_properties[food]['fat']
            sugar = food_properties[food]['sugar']

            trial = {
                'participant': participant,
                'block': block,
                'trial_number': trial_num,
                'food': food,
                'reaction_time': reaction_time,
                'rating': rating,
                'fat': fat,
                'sugar': sugar
            }
            #linking two things together, dictionaries
            all_trials.append(trial)

# Create DataFrame
df = pd.DataFrame(all_trials)

# Validate logic: rating is only missing if RT is missing
assert all(df[df['rating'].isna()]['reaction_time'].isna())

"""The data are stored in a dataframe object, which we have called df
To access items in the dataframe, we need to type "df"
"""

#If we want to see the data, we can just type
df.columns

# To see anything in df we will need to reference df first
df.columns

# We can also look at the values of columns
# All of these will access the food column
df.food
df['food']
df.iloc[:,3] #first row df.iloc[0,3]

# Try here with RT

# To analyze this data, we will first need to remove any missing trials
# let's find the missing values
df.reaction_time[df.reaction_time.isna()==True]
#df.reaction_time.dropna()

df.reaction_time[df.reaction_time > 3]

# What would we change to see RTs < 2 only?

# make a new data frame with no missing values
df1 = df[df.reaction_time.isna()==True]

# Now we want to perform some calculations on this data-set
# let's start by summarizing, for one person the health rating

# Filter for participant 1 and the 'health' block
participant_id = 1
health_block = df[(df['participant'] == participant_id) & (df['block'] == 'health')]
#food is 75 so health will be 75 trials

# Remove missing ratings (i.e., where RT was missing)
valid_ratings = health_block['rating'].dropna()

# Calculate the average health rating
average_health_rating = valid_ratings.mean()

print(f"Participant {participant_id}'s average health rating: {average_health_rating:.2f}")

#Try for health only for high-fat
health_block = df[(df['participant'] == participant_id) & (df['block'] == 'health') & (df['fat'] == 'high')]
valid_ratings = health_block['rating'].dropna()

average_health_rating = valid_ratings.mean()
print(f"Participant {participant_id}'s average high fat health rating: {average_health_rating:.2f}")

#Try for low only

health_block = df[(df['participant'] == participant_id) & (df['block'] == 'health') & (df['fat'] == 'low')]
valid_ratings = health_block['rating'].dropna()

average_health_rating = valid_ratings.mean()
print(f"Participant {participant_id}'s average low fat health rating: {average_health_rating:.2f}")


#Try for Loops
for participant_id in range (1,21):
  for x in ['low','high']:
    high_block = df[(df['participant'] == participant_id) & (df['block'] == 'health') & (df['fat'] == x)]
    valid_ratings = high_block['rating'].dropna()
    average_health_rating = valid_ratings.mean()
    print(f"Participant {participant_id}'s average health rating: {average_health_rating:.2f} for {x} foods")

#Now let's create a new dataframe and store each persons average RT and rating for high and low fat foods

# Group by participant, block, and fat level
summary_df = (
    df
    .dropna(subset=['rating', 'reaction_time'])  # Exclude trials with missing values
    .groupby(['participant', 'block', 'fat'])
    .agg(
        average_rating=('rating', 'mean'),
        average_reaction_time=('reaction_time', 'mean'),
        trial_count=('rating', 'count')  # Optional: to see how many valid trials per group
    )
    .reset_index()
)

print(summary_df.head()) #only four columns

# Pivot to wide format
wide_df = summary_df.pivot_table(   #from long to the wide
    index='participant',
    columns=['block', 'fat'],
    values=['average_rating', 'average_reaction_time']
)
# all data should keep the participant id
#wide_df

# Step 3: Flatten column names
wide_df.columns = [f'{stat}_{block}_{fat}' for stat, block, fat in wide_df.columns]
wide_df = wide_df.reset_index()

print(wide_df.head())

# Here try and simulate a different dataset - a monetary choice task where the participant
# selects between an immediate vs delayed reward. Compare the RT between when the participant
# chooses the immediate vs delayed option

# navigate to the directory
data=pd.read_csv("https://raw.githubusercontent.com/CaitlinLloyd/Psychology_Programming2025/refs/heads/main/Data/DelayDisc_example.csv")

data

# figure out whether left or right column is delayed (1 is left, 2 is right)
data['delayed_opt']= "none" #make all none so we definitely get 1 or 2
data.loc[data['delay_left'] < data['delay_right'],'delayed_opt'] = 2
data.loc[data['delay_left'] > data['delay_right'],'delayed_opt'] = 1

#
data['delayed_opt_chose']= "none" #make all none so we definitely get 1 or 2
data.loc[data['delayed_opt'] == data['choice'],'delayed_opt_chose'] = 1
data.loc[data['delayed_opt'] != data['choice'],'delayed_opt_chose'] = 1

# Now summarize the RT for each person when they chose delayed vs chose sooner reward
for participant in range(1, 3):
 for x in [1,0]:

  high_block = data[(data['participant'] == participant) & (data['delayed_opt_chose'] == x)]

  valid_ratings = high_block['rt'].dropna()


# Calculate the average health rating
  average_RT = valid_ratings.mean()
  print(f"Participant {participant}'s average RT: {average_RT:.2f} for {x} trials")

"""## This is the homework exercise

"""

## Here calculate the average earnings per person and the number of times they chose delayed vs sooner

# if left, use money_left
data.loc[data['choice'] == 1, 'earnings'] = data.loc[data['choice'] == 1, 'money_left']

# if right, use money_right
data.loc[data['choice'] == 2, 'earnings'] = data.loc[data['choice'] == 2, 'money_right']

# now loop
for participant in range(1, 3):

  # get this participant's data
  person_data = data[data['participant'] == participant]

  # drop missing earnings
  valid_earnings = person_data['earnings'].dropna()

  # calculate average earnings
  average_earnings = valid_earnings.mean()

  # count delayed vs sooner
  delayed_chose = (person_data['delayed_opt_chose'] == 1).sum()
  sooner_chose  = (person_data['delayed_opt_chose'] == 0).sum()

  # print summary
  print(f"Participant {participant}'s average earnings: {average_earnings:.2f}")
  print(f"  chose delayed: {delayed_chose} times")
  print(f"  chose sooner : {sooner_chose} times")

## Upload solution to Github

"""## Extra
## These are hard exercises - not homework, for extra practice
"""

# Hard

# Here simulate your own Delay Discounting Task and calculate some average metrics

# Very hard
# One outcome of interest is the discount rate, k, which denotes extent to which someone discounts
# value of delayed rewards (higher values = less patient)

# Here you can use chatGPT to get the formula for k - see whether you can calculate for each person
# in your dataset